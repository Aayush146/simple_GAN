# -*- coding: utf-8 -*-
"""simple_GANs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g1N8J6AX22mp8FIK012E8aRkYvhUBanE
"""

from google.colab import drive
drive.mount('/content/drive')

import torch
import torch.nn as nn
import torch.optim as optim 
import torchvision
import torchvision.datasets as datasets
from torch.utils.data import DataLoader
import torchvision.transforms as Transforms
from torch.utils.tensorboard import SummaryWriter

class Discriminator(nn.Module):
  def __init__(self, image_dim):
    super().__init__()
    self.disc = nn.Sequential(
        nn.Linear(image_dim, 128), 
        nn.LeakyReLU(0.1), 
        nn.Linear(128,1), 
        nn.Sigmoid()
    )

  def forward(self, x):
    return self.disc(x)

class Generator(nn.Module):
  def __init__(self, z_vector, image_dim):
    super().__init__()
    self.gen = nn.Sequential(
        nn.Linear(z_vector, 256), 
        nn.LeakyReLU(0.1),  
        nn.Linear(256, image_dim), 
        nn.Tanh() # image dimension is 754 as mnist images are 28 by 28 by 1
    )

  def forward(self, z_vector):
    return self.gen(z_vector)

# get the hyperparameters sorted

device = 'cuda' if torch.cuda.is_available() else 'cpu'
lr = 3e-4
z_dim = 64
image_dim = 28*28*1
batch_size = 32
num_epochs = 50

disc = Discriminator(image_dim).to(device)
gen = Generator(z_dim, image_dim).to(device)
fixed_noise = torch.randn((batch_size, z_dim)).to(device) # get to se how the fixed noise has chnaged over all the epochs as we train a GAN
transforms = Transforms.Compose([Transforms.ToTensor(), Transforms.Normalize((0.1307,), (0.3081,))])

# create the dataset 
dataset = datasets.MNIST( root = 'dataset/', transform = transforms, download = True)
dataload = DataLoader(dataset, batch_size = batch_size , shuffle = True)
optim_disc = optim.Adam(disc.parameters(), lr = lr)
optim_gen = optim.Adam(gen.parameters(), lr = lr)
criterion = nn.BCELoss()
writer_fake = SummaryWriter(f'runs/GAN_MNIST/fake')
writer_real = SummaryWriter(f'runs/GAN_MNIST/real')
step = 0

# train the GAN 

for epoch in range(num_epochs):
  for batch_idx, (real_ims, _) in enumerate(dataload):
    real_ims = real_ims.view(-1, 784)
    batch_size = real_ims.shape[0]

    ## training the discriminator V = expectation(log(D(real))) + expectation(log(1 - D(G(z))))

    # the noise vector is generated from a gaussian/normal distribution  
    '''the over all idea of this training is to update the generator paramters such that whenever the discriminator is given fake images, 
    it outputs 0.5 rather than zero'''
    
    noise = torch.randn((batch_size, z_dim)).to(device) # sampling noise vector from gaussian distribution 
    fakes = gen(noise) # generated images 
    disc_real = disc(real_ims).view(-1) # sigmoid outputs for the training dataset 
    loss_real = criterion(disc_real, torch.ones_like(disc_real)) # average confidence that the discriminator thinks the real images are real  
    disc_fake = disc(fakes).view(-1) #confidence values that the discriminator thinks these are real images
    loss_fake = criterion(disc_fake, torch.zeros_like(disc_fake)) # average that the discriminator thinks these are real images 
    lossD = (loss_real + loss_fake) / 2 # add both the confience values 

    disc.zero_grad()
    lossD.backward(retain_graph = True)
    optim_disc.step()

    ## train the generator 
    # note that the discriminator is being trained for the same number of steps i.e one. 

    output = disc(fakes).view(-1)
    lossG = criterion(output, torch.ones_like(output)) # give it a vector full of ones to say that these images are real. 
    gen.zero_grad()
    lossG.backward()
    optim_gen.step() 


    if batch_idx == 0:
      
      print( f"Epoch [{epoch}/{num_epochs}] Batch {batch_idx}/{len(dataload)} \ Loss D: {lossD:.4f}, loss G: {lossG:.4f}")

      with torch.no_grad():
          fake = gen(fixed_noise).reshape(-1, 1, 28, 28)
          data = real_ims.reshape(-1, 1, 28, 28)
          img_grid_fake = torchvision.utils.make_grid(fake, normalize=True)
          img_grid_real = torchvision.utils.make_grid(data, normalize=True)

          writer_fake.add_image(
              "Mnist Fake Images", img_grid_fake, global_step=step
          )
          writer_real.add_image(
              "Mnist Real Images", img_grid_real, global_step=step
          )
          step += 1

"""## DCGAN"""

class discriminator_2(nn.Module):